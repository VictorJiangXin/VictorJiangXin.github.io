[{"title":"Python_note","date":"2019-03-27T08:57:52.000Z","path":"/Python-note/","text":"参数在运行程序中，经常需要输入一系列的参数，用于指定文件夹之类的信息。常用的相关包有import argparse。下面是常用的用法123parser = argparse.ArgumentParser(description=&apos;&apos;)parser.add_argument(&apos;--outf&apos;, default=&apos;./data/&apos;, help=&apos;folder to output images and model checkPoint&apos;)args = parser.parse_args()","comments":true,"tags":[{"name":"Python","slug":"Python","permalink":"http://victorjiangxin.github.io/tags/Python/"}]},{"title":"python3安装pymssql","date":"2018-07-22T10:57:46.000Z","path":"/python3-install-pymssql/","text":"提要由于在做项目中，需要通过python操作SQL Server数据库，在查看相关资料后，发现可以使用pymssql包，对数据库进行操作。本人使用的Python版本为3.5，查阅多种资料，都是推荐使用 pip install pymssql 但是，每次安装的时候，都出现错误，后来又尝试直接从pypi.org网站下载pymssql的包进行安装，进入相关包的路径后，输入python setup.py install但是仍旧是一堆错误。 解决在查看各种博客后，最终找到了解决方法。在微软的帖子里 微软的SQL帮助核心原因是，pip安装的程序需要再专门的网站里下载，即要下载对应版本的数据。下载地址 我是python3.5,64位，因此下载了 pymssql‑2.1.4.dev5‑cp35‑cp35m‑win_amd64.whl 然后进入下载的文件夹，运行指令 pip install pymssql‑2.1.4.dev5‑cp35‑cp35m‑win_amd64.whl从而成功安装。问题顺利解决","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://victorjiangxin.github.io/tags/python/"},{"name":"pymssql","slug":"pymssql","permalink":"http://victorjiangxin.github.io/tags/pymssql/"}]},{"title":"通过geth Json-Rpc接口遇到的坑","date":"2018-07-19T08:18:48.000Z","path":"/etheStudy/","text":"使用Python访问Geth遇到的问题在使用python对Geth提供的Json-RPC服务器进行访问时，一直返回由于目标计算机积极拒接、无法连接的错误，因此作出以下尝试： 使用python访问百度等官方网站，经测试，可以访问，说明当前配置无问题，问题出现在服务器端。 进入服务器，用netstat | grep 8545查看相关端口状态，发现端口一直处于Stopped状态。geth无法正常运行。经检测是磁盘空间不足，Geth数据无法同步，导致Geth运行失败，停止尝试。将.ethereum文件夹全部删除，重新运行geth –rpc，发现8545端口正常运行。 geth虽然端口正常运行，但是python仍旧无法去访问JsonRPC服务器。于是运行另一种geth命令。 geth –rpc –rpcaddr 10.21.41.1 –rpcport 8545。运行后，python能够从geth客户端获取信息问题解决。 问题原因，一开始访问 (ethereum JSONRPC的WIKI)[https://github.com/ethereum/wiki/wiki/JSON-RPC]里面提供了两种运行命令：geth --rpc该种默认rpcaddr是localhost.rpcport是8545。geth --rpc --rpcaddr &lt;xx&gt; --rpcport &lt;port&gt;该种情况是定义了IP和端口号，我以为localhost应该就是服务器的内网IP即 10.21.41.1但是，实际python访问是不行的，必须定义好rpcaddr，定义它为geth所在服务器的IP地址，从而才可以访问。","comments":true,"tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://victorjiangxin.github.io/tags/以太坊/"},{"name":"Geth","slug":"Geth","permalink":"http://victorjiangxin.github.io/tags/Geth/"},{"name":"Json-RPC","slug":"Json-RPC","permalink":"http://victorjiangxin.github.io/tags/Json-RPC/"}]},{"title":"HunterCatchRabbits","date":"2018-07-18T02:00:22.000Z","path":"/HunterCatchRabbits/","text":"题目描述：假设卧底和特工有n个接头地点，编号为0和n-1。卧底每天晚上仅能换到相邻的接头地点，而特工每天白天在一个接头地点检查。 特工告诉你每天检查的接头地点的编号，希望你分析一下是否一定能与卧底碰头。 输入描述：首先输入n和k（n&lt;100,k&lt;1000），分别表示接头地点的个数和特工检查的天数；接下来输入k个整数，表示特工每天检查的接头地点的编号。 输出描述：如果一定能与卧底碰头，输出Yes，否则输出No。 测试用例：1235 61 2 3 3 2 1Yes 测试代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std; bool canCatchRibbit(vector&lt;int&gt; holeNums, vector&lt;int&gt; checked)&#123; int k = holeNums.size(); int n = checked.size(); bool flag = true; int cnt = n; // cnt为兔子能待的洞的个数，初试化为所有洞的个数 for (int i = 0; i &lt; k; i++) &#123; int holeNum = holeNums[i] - 1; // holeNum为洞的编号在vector中的序号， // 如：编号为1的洞在vector里面存的是0 if (checked[holeNum] == 1) &#123; checked[holeNum] = 0; cnt--; &#125; if (cnt == 0) // 如果兔子能待的洞的个数为0，则兔子肯定会被逮住 &#123; flag = false; break; &#125; for (int j = 0; j &lt; n; j++) &#123; if (checked[j] == 1) &#123; checked[j] = 0; cnt--; if (j&gt;0 &amp;&amp; checked[j - 1] == 0) &#123; checked[j - 1] = 1; cnt++; &#125; if (j &lt; n - 1 &amp;&amp; checked[j + 1] == 0) &#123; checked[j + 1] = 1; cnt++; j++; //原来值为0的洞现在为1后是不能往相邻的洞跳，故继续检查下一个洞 &#125; &#125; &#125; &#125; return flag;&#125; int main()&#123; int n, k; // n为洞的个数，k为检查的天数 cin &gt;&gt; n &gt;&gt; k; vector &lt;int&gt; holeNums(k, 0); // holeNums为每天检查的洞的编号 for (auto &amp;m : holeNums) cin &gt;&gt; m; vector&lt;int&gt; checked(n, 1); // checked为每天检查的洞中是否有兔子,可能有兔子则值为1， // 一定没兔子则值为0，全部初始化为1； bool flag = canCatchRibbit(holeNums, checked); if (!flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0;&#125;","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://victorjiangxin.github.io/tags/算法/"}]},{"title":"linux文件编程","date":"2018-04-25T16:00:00.000Z","path":"/linux文件编程/","text":"概述Linux系统讲所有设备都当作文件来处理，因此Linux文件编程极其重要！linux文件编程设计到文件的读、写定位等各种操作。其中对文件的操作都只能由内核态完成，用户态想要访问文件只能通过系统调用。Linux文件编程中，最重要的一个概念便是文件描述符fd，所有文件的操作都通过文件描述符进行，每个文件对应一个文件描述符。打开现存文件或新建文件时，内核会返回一个文件描述符，读写文件也需要使用文件描述符。 需要添加的函数库123#include &lt;fcntl.h&gt; //文件控制选项头文件#include &lt;unistd.h&gt; //针对系统调用封装#include &lt;sys/type.h&gt; 文件操作open 打开文件函数原型： int open(char *name, int how)功能： 打开一个文件 name: 文件名 how: 文件操作限制 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 读写 return -1: 打开失败 非零: 对应的文件描述符 create 创建文件函数原型： int fd = create(char *filename, mode_t mode)功能： 创建一个文件，如果源文件存在，则讲该文件清空 filename： 文件名 mode: 访问模式 COPYMODE return -1: 打开失败 非零: 成功创建 read 读数据函数原型: ssize_t read(int fd, void *buf, size_t qty)功能： 读取qty长度的数据到缓存buf中 fd: 所读文件的文件描述符 buf: 缓存 qty: 读取文件的长度 return: -1: 读取错误 非零: 读取的长度 write 写数据函数原型： ssize_t write(int fd, void *buf, size_t amt)功能： 将buf中数据写入文件中 fd: 所写文件的文件描述符 buf: 缓存 amt: 写进文件的长度 return: -1: 读取错误 非零: 写入的长度 lseek 定位文件指针函数原型： off_t lseek(int fd, off_t dist, int base)功能： 将文件指针定位到制定位置 fd: 操作的文件描述符 dist: 相对基位置的偏移量 base: 基位置 SEEK_SET 文件的开始 SEEK_CUR 当前位置 SEEK_END 文件结尾 return -1: 错误 其他： 指针变化前的位置 close 关闭文件函数原型： int close(int fd)功能： 关闭文件 fd: 需要关闭的文件 return -1: 错误 0: 关闭正确 处理系统调用中的错误errno内核通过全局变量来指定系统调用的类型，每个程序可以访问到该变量。一般不用它判断系统调用错误。 perror使用 perror(string)系统会自己查找调用错误的类型，并且将错误信息打印。","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://victorjiangxin.github.io/tags/linux/"},{"name":"文件操作","slug":"文件操作","permalink":"http://victorjiangxin.github.io/tags/文件操作/"}]},{"title":"linux获取时间及Socket编程","date":"2018-04-21T16:00:00.000Z","path":"/linux获取时间及Socket编程/","text":"如何获取时间UNIX时间戳：从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。UTC时间：世界协调时。以地球自转为基础的时间标准。 UTC表示方式为 年月日时分秒。 获取UNIX时间戳C运行库：#include &lt;sys/time.h&gt;运行环境： C语言运行环境函数： gettimeofday(struct timeval* tv, struct timezone* tz)功能： 获取当前UNIX时间戳相关结构体：123456789struct timeval&#123; long tv_sec; //seconds long tv_usec; //microSeconds&#125;struct timezone&#123; int tz_minuteswest; //diff of greenwich int tz_dsttime; //type of DST correction&#125; 获取UTC时间C运行库：#include &lt;time.h&gt;运行环境： C语言运行环境函数1： char *ctime(const time_t *timer)功能1： 将UNIX时间戳转化成 Www Mmm dd hh:mm:ss yyyy (Mon Aug 13 08:23:14 2012)形式函数2： struct tm *gmtime(time_t *timer)功能2： 将UNIX时间转化成struct tm结构。相关结构体：1234567891011struct tm&#123; int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;&#125; 注意： UTC时间年是以1900为参考点，记时间时需要year+1900， 时区是0时区，如果按照北京时间（东8区）需要tm_hour+8 测试代码：12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;struct tm *GetBeijingTime();int main()&#123; struct tm *beijingTime; beijingTime = GetBeijingTime(); printf(&quot;%d/%d/%d %2.2d:%2.2d:%2.2d\\n&quot;, beijingTime-&gt;tm_year, beijingTime-&gt;tm_mon, beijingTime-&gt;tm_mday, beijingTime-&gt;tm_hour, beijingTime-&gt;tm_min, beijingTime-&gt;tm_sec);&#125;struct tm *GetBeijingTime()&#123; struct timeval tv; struct tm *BeijingTime; gettimeofday(&amp;tv, NULL); BeijingTime = gmtime((time_t*)&amp;(tv.tv_sec)); BeijingTime-&gt;tm_year += 1900; BeijingTime-&gt;tm_hour += 8; BeijingTime-&gt;tm_mon += 1; return BeijingTime;&#125; Socket编程包含的库：12#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt; 服务器端 创建socket int socket(int domain, int type, int protocol) domain: 协议域，决定了socket的地址类型。 AF_INET: 用于IPV4网络通信 AF_UNIX: 单一Unix系统中进程间通信 AF_INET6: 用于IPV6网络通信 type: 制定socket类型。 SOCK_STREAM: 流式，一般用于TCP通信 SOCK_DGRAM: 数据包式，一般用于UDP通信 protocaol: 制定协议。 IPPROTO_TCP表示TCP协议，IPPROTO_UDP表示UDP协议，为0时自动选择type默认协议 return: -1 错误； 非负值 成功 绑定socket和端口号 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) sockfd: socket返回的套间字描述符，类似于文件描述符。 addr: 有个sockaddr类型数据的指针，指向的时被绑定结构变量 12345678910111213141516171819202122//IPV4的sockaddr地址结构struct sockaddr_in&#123; sa_family sin_family; //协议类型，AF_INET in_port_t sin_port; //端口号 struct in_addr sin_addr; //ip地址&#125;;struct in_addr&#123; uint32_t s_addr;&#125;//有关于sockaddr的相关函数htons() 将整形类型转换成网络字节序 比如 htons(INADDR_ANY),让系统自动获取本地IP地址htonl() 将长整形转换为网络字节序inet_pton(int af, char *str, pvoid addrbuf) 将点分十进制IP地址转换成网络字节 af: 协议域，与socket的domain一致 str: 要转换的地址 127.0.0.1 addrbuf: sinaddr的指针inet_ntop(int af, pvoid addrbuf, char *str, size_t len) 将网络字节序转换成分十进制IO地址 af: 协议域，与socket的domain一致 addrbuf: sinaddr的指针 str: 转换成的地址 len: 字节单位长度 addrlen: 地址长度 监听端口号 int listen(int sockfd, int backlog) sockfd: 要监听的sock描述字 backlog: socket可以排队的最大连接数 接收用户请求 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) sockfd: 服务器socket描述字 addr: 地址指针，保存用户对应的地址 addrlen： 地址长度。保存用户地址的长度 return: 一旦accept某个客户机请求成功，返回一个新的描述符，用于标识具体客户的TCP连接。 从socket中读取字符 ssize_t read(int fd, void *buf, size_t count) fd: 读取的用户对应的套间字描述字 buf: 保存接收信息的缓冲区 count: 读取的长度 return: 如果大于零表示读取的长度，返回0表示文件读取结束，小于0表示发生错误 向socket发送信息 ssize_t write(int fd, const void *buf, size_t count) fd: 发送的用户对应的套间字 buf: 缓冲区 count: 发送的信息长度 return: 如果大于零表示发送的长度，小于0表示发生错误 关闭socket int close(int fd) fd: accept返回的连接描述字，每个连接有一个，生命周期为连接周期。 ps: sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。客户端 创建socket int socket(int domain, int type, int protocol) domain: 协议域，决定了socket的地址类型。 AF_INET: 用于IPV4网络通信 AF_UNIX: 单一Unix系统中进程间通信 AF_INET6: 用于IPV6网络通信 type: 制定socket类型。 SOCK_STREAM: 流式，一般用于TCP通信 SOCK_DGRAM: 数据包式，一般用于UDP通信 protocaol: 制定协议。 IPPROTO_TCP表示TCP协议，IPPROTO_UDP表示UDP协议，为0时自动选择type默认协议 return: -1 错误； 非负值 成功 连接指定服务器 int connect(int sockfd, struct sockaddr *addr, socklen_t addrlen) sockfd：客户端的sock描述字 addr: 服务器的地址 addrlen: socket地址长度 向socket发送信息 ssize_t write(int fd, const void *buf, size_t count) fd: 发送的用户对应的套间字 buf: 缓冲区 count: 发送的信息长度 return: 如果大于零表示发送的长度，小于0表示发生错误 关闭socket int close(int fd) fd: accept返回的连接描述字，每个连接有一个，生命周期为连接周期。 实例客户端连接服务器，服务器向客户端发送当地时间，客户端接收并显示。服务器端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define DEFAULT_PORT 6666#define BUF_LEN 128struct tm *GetBeijingTime();int main()&#123; int SocketServer; struct sockaddr_in ServerAddr; char Buf[BUF_LEN]; //create socket if((SocketServer = socket(AF_INET, SOCK_STREAM, 0)) == -1)&#123; printf(&quot;create socket error!\\n&quot;); exit(0); &#125; //create addr memset((char*)&amp;ServerAddr, 0, sizeof(ServerAddr)); ServerAddr.sin_family = AF_INET; ServerAddr.sin_addr.s_addr = htonl(INADDR_ANY); ServerAddr.sin_port = htons(DEFAULT_PORT); //bind the socket with address if(bind(SocketServer, (struct sockaddr*)&amp;ServerAddr, sizeof(ServerAddr)) == -1)&#123; printf(&quot;bind socket with addr fail!\\n&quot;); exit(0); &#125; //listen if(listen(SocketServer, 20) == -1)&#123; printf(&quot;listen error!\\n&quot;); exit(0); &#125; printf(&quot;server: waitting for client connect.........\\n&quot;); //loop for accept while(1)&#123; int SocketClient; struct sockaddr_in ClientAddr; char ClientAddrString[30]; socklen_t ClientAddrLen; if((SocketClient = accept(SocketServer, (struct sockaddr*)&amp;ClientAddr, &amp;ClientAddrLen)) == -1)&#123; printf(&quot;accept socket error!\\n&quot;); exit(0); &#125; inet_ntop(AF_INET, &amp;ClientAddr.sin_addr, ClientAddrString, sizeof(ClientAddrString)); printf(&quot;server: %s connecting .....\\n&quot;, ClientAddrString); //get the time struct tm *beijingTime; beijingTime = GetBeijingTime(); sprintf(Buf, &quot;TIME: %d/%d/%d %2.2d:%2.2d:%2.2d\\n&quot;, beijingTime-&gt;tm_year, beijingTime-&gt;tm_mon, beijingTime-&gt;tm_mday, beijingTime-&gt;tm_hour, beijingTime-&gt;tm_min, beijingTime-&gt;tm_sec); //send the time if(write(SocketClient, Buf, strlen(Buf)) == 0) printf(&quot;server: send message error!\\n&quot;); //close the socket connect close(SocketClient); printf(&quot;server: close the client\\n&quot;); &#125; close(SocketServer); return 1;&#125;struct tm *GetBeijingTime()&#123; struct timeval tv; struct tm *BeijingTime; gettimeofday(&amp;tv, NULL); BeijingTime = gmtime((time_t*)&amp;(tv.tv_sec)); BeijingTime-&gt;tm_year += 1900; BeijingTime-&gt;tm_hour += 8; BeijingTime-&gt;tm_mon += 1; return BeijingTime;&#125; 客户端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define BUF_LEN 128int main(int argc, char** argv)&#123; int SocketClient; char Buf[BUF_LEN]; struct sockaddr_in ServerAddr; //create socket if((SocketClient = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123; printf(&quot;create socket error\\n&quot;); exit(0); &#125; //set the server&apos;s addr memset((char*)&amp;ServerAddr, 0, sizeof(ServerAddr)); ServerAddr.sin_family = AF_INET; int port = atoi(argv[2]); ServerAddr.sin_port = htons(port); if(inet_pton(AF_INET, argv[1], &amp;ServerAddr.sin_addr) &lt;= 0)&#123; printf(&quot;inet_pton error!\\n&quot;); exit(0); &#125; //connect if(connect(SocketClient, (struct sockaddr*)&amp;ServerAddr, sizeof(struct sockaddr)) &lt; 0)&#123; printf(&quot;connect error!\\n&quot;); exit(0); &#125; memset(Buf, 0, BUF_LEN); //read the message from server if(recv(SocketClient, Buf, BUF_LEN, 0) &lt; 0)&#123; printf(&quot;recv error!!\\n&quot;); exit(0); &#125; printf(&quot;Client: recv from server-&gt; %s\\n&quot;, Buf); //close socket close(SocketClient); return 1;&#125;","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://victorjiangxin.github.io/tags/linux/"},{"name":"socket","slug":"socket","permalink":"http://victorjiangxin.github.io/tags/socket/"}]},{"title":"kerberos认证浅析","date":"2018-04-14T16:00:00.000Z","path":"/kerberos认证/","text":"什么是kerberosKerberos是个用于安全认证的第三方协议，它采用了传统的共享密钥的方式，实现了在网络环境不一定保证安全的环境下，Client和Server之间的通信。 kerberos协议基本原理 A与B之间有一个密钥key(A,B)，这个密钥只有它们两者拥有。当A需要向B证明它是A时，发送两条信息。一条为A的用户信息的明文，另一条为使用密钥key加密过的明文信息。B接收后，用密钥key进行解密，然后将解密后的信息与明文信息比较。如果他们是一样的，则表明对方就是A。从而，B确认A的身份。 引入KDC：key(A,B)从何而来为了保证认证的安全性，key(A,B)应该是有时效性的，不能是固定的。因此KDC在整个认证系统中起共同信任的第三方作用。 大概流程 A向KDC发出申请，申请中包含了A的身份信息 KDC查询白名单，如果A存在则向A发送两条信息 第一条为Encrypt(key(A,B), Pubkey_A)，使用A的公钥加密的key(A,B) 第二条为Encrypt(A_Info+key(A,B), Pubkey_B)，使用B的公钥加密的A_Info与key(A,B)信息 A使用私钥对Encrypt(key(A,B), Pubkey_A)信息解密，得到key(A,B) A开始向B进行认证申请，发送两条信息 第一条为Encrypt(A_Info+Timestamp, key(A,B))，使用key(A,B)加密的A_Info和时间戳信息 第二条为Encrypt(A_Info+key(A,B), Pubkey_B) B接收到A发送的信息后： 先用私钥解密Encrypt(A_Info+key(A,B), Pubkey_B)，得到key(A,B) 然后用Key(A,B)解码Encrypt(A_Info+Timestamp, key(A,B))，比较A_Info，相同则成功认证。加时间戳的目的B每次接收到A的认证信息后，如果发现时间戳与当前时间在范围外，则判定失效，保证安全Kerberos的优点 较高的性能。KDC参与次数少，相比较完全依赖可信赖的第三方方案比较，具有较大的性能提升 实现了双向验证","comments":true,"tags":[{"name":"密码学","slug":"密码学","permalink":"http://victorjiangxin.github.io/tags/密码学/"},{"name":"kerberos认证","slug":"kerberos认证","permalink":"http://victorjiangxin.github.io/tags/kerberos认证/"}]},{"title":"github使用相关","date":"2018-04-12T16:00:00.000Z","path":"/github使用相关/","text":"常用操作及代码 生成SSH key ssh -keygen -t rsa ssh -T git@github.com 克隆版本库 git clone 上传文件 git add &lt;文件名，如果是全部，可以用add .&gt; git commit -m “文件描述” git push origin master （把本地代码推送到远程master分支） git pull -u origin master (把远程代码拉下，保证代码同步) 将本地项目与Github上的一个项目进行关联。先切换到目的目录，执行下面命令,把远程仓库的名字命名为origingit remote add origin git@github.com:&lt;USERNAME&gt;/&lt;User.resource&gt;.git 提交项目前，注意！！！一定要先设置用户名与邮箱 12345678910git config —global user.name &quot;&lt;your name&gt;&quot;git config —global user.email &quot;&lt;your email&gt;&quot;``` * 创建分支 `git checkout -b &lt;branch name&gt;` # 本地已有版本库，要推送至Github首先，Github上已有一个Repository, `git@github.com:VictoryJiangXin/mShell.git`然后，进入目录，比如f:\\mShell然后命令步骤如下： git initgit remote add &lt;Repository’s name&gt; git@github.com:VictoryJiangXin/mShell.gitgit add git commit -m ““git push -u &lt;Repository’s name&gt; master`","comments":true,"tags":[{"name":"Github","slug":"Github","permalink":"http://victorjiangxin.github.io/tags/Github/"}]},{"title":"开源代码License","date":"2018-04-10T16:00:00.000Z","path":"/GithubLicense相关/","text":"概论开源代码有个很重要的文件，License这涉及到制作者的知识产权，因此特查看相关博客。下面一张图进行说明。图片来源：阮一峰 老师博客","comments":true,"tags":[{"name":"Github","slug":"Github","permalink":"http://victorjiangxin.github.io/tags/Github/"},{"name":"开源许可证","slug":"开源许可证","permalink":"http://victorjiangxin.github.io/tags/开源许可证/"}]},{"title":"SqlServer使用","date":"2018-04-10T07:01:52.000Z","path":"/SqlServer使用/","text":"Sql Server相关在使用Sql Server进行存储时，碰到两个巨大的坑！ 一个就是关于数据库版本的问题，SQL Server在WIN7系统上无法运行2017的版本，智能运行2014的版本。 一个就是SQL Server的自身版本问题，SQL Server有两种，一种是EXPRESS版，它最多只能存储10G的数据，一种是企业版，它能存储不限量的数据。 SSMS连接SQL Server数据库在使用SQL Server时，我们常常使用SSMS操作数据库，对数据库进行可视化的操作。在使用SSMS操作数据库时，首先要进行数据库连接我的数据库是默认安装的，命名为SQ2，但是，在填写数据库服务器名时，我填写SQ2，却一直无法连接到数据库，最后才发现，要使用localhost\\SQ2作为名字，才可以进行连接！","comments":true,"tags":[{"name":"数据库","slug":"数据库","permalink":"http://victorjiangxin.github.io/tags/数据库/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://victorjiangxin.github.io/tags/SQL-Server/"}]},{"title":"SQL数据库相关操作","date":"2018-04-03T16:00:00.000Z","path":"/数据库/","text":"数据库定义语句 CREAT语句_建表CREAT语句用于创建数据库、表、视图等操作。语句格式如下：1234CREATE TABLE &lt;表名&gt;( &lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;], &lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;], &lt;表级完整性约束条件&gt;); &lt;表级完整性约束条件&gt;: 涉及一个或多个属性列的完整性约束条件常用完整性约束: 主码约束: PRIMARY KEY 参照完整性约束: 唯一性约束： UNIQUE 非空值约束： NOT NULL 取值约束： CHECK 数据类型： 在SQL Server中，有几种主要的类型——文本、数字、二进制数据和日期 文本类型 CHAR(size) 保持固定长度的字符串。n的取值：1-8000 VARCHAR(size) 保持可变长度的字符串。在括号中指定字符串的最大长度，最多为8000个字符，效率没CHAR高 TEXT 最多存放长度为 2^31-1 个字符的字符串 NCHAR(n) 固定长度，Unicode字符串数据。n的取值1-4000 NVARCHAR(n) 可变长度，Unicode字符串数据。n的取值范围1-4000 NTEXT 长度可变的Unicode数据，字符串最大长度为2^30-1 数字类型 BIT 0/1或NULL的数据类型 BIGINT 8字节存储的INT数据类型 INT 4字节存储的INT数据类型 SMALLINT 2字节存储的INT数据类型 TINYINT 1字节存储的INT数据类型 DECIMAL[(P[,S])] []表示可选择的。固定精度和小数位数，p表示精度，s表示小数位数 FLOAT[(n)] 浮点数，其中n用于存储flaot数值尾数的尾数，用于确定精度 二进制类型 BINARY(n) 固定长度，n的取值：1~8000 VARBINARY(n) 可变长度，最多为长度n，n的取值：1~8000 IMAGE 长度可变的二进制数据，从0到2^31-1个字节 时间类型 TIME 00:00:00.0000000到23:59:59:9999999 DATE 0001-01-01到9999-12-31 SMALLDATETIME 日期范围:1900-01-01到2079-06-06 时间范围:00:00:00到23:59:59 DATATIME 日期范围:1753-01-01到9999-12-31 时间范围:00:00:00到23:59:59.997 DATATIME2 日期范围:0001-01-01到9999-12-31 时间范围:00:00:00到23:59:59.9999999 举例：创建一个学生表，包括学号、姓名、性别、年龄及所在系。其中学号不能为空，且唯一，姓名取值也唯一。 1234567CREATE TABLE Student( StudentNumber CHAR(5) NOT NULL UNIQUE, StudentName CHAR(20) UNIQUE, StudentSex CHAR(1), StudentAge INT, StudentDept CHAR(15)); CREAT语句_建索引建立索引是加快查询速度的有效手段。索引建立方式： DBMS自行建立 PRIMARY KEY UNIQUE DBA或表的属主（建表的人）根据需要建立。 维护索引：DBMS自动完成语句格式:CREAT [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...); 索引可以建立在该表的一列或多列上。次序表示升序或者降序表示，升序：ASC，降序：DESC。缺省值：ASCUNIQUE表示索引的每一个索引值只对应唯一的数据记录。CLUSTER表示要建立的索引是聚簇索引。注意：如果是含重复值的属性列不能建立UNIQUE索引，聚簇索引，基表中的数据也需要按指定的聚簇属性的升序或降序存放。 ALTER语句ALTER语句用于修改各表项的内容，其语句格式如下所示： 1234ALTER TABLE &lt;表名&gt; [ADD &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [DROP &lt;完整性约束名&gt;] [MODIFY &lt;列名&gt; &lt;数据结构&gt;]; -表名：要修改的基本表-ADD子句：增加新列和新的完整性约束条件-DROP子句：删除指定的完整性约束条件-MODIFY子句：用于修改名列名和数据类型-只能间接删除属性列 * 把表中要保留的列及其内容复制到一个新表中 * 删除原表 * 再将新表命名为原表名 -不能修改完整性约束-不能为已有列增加完整性约束举例：向Student表中增加“入学时间”列，其数据类型为日期型。 ALTER TABLE Student ADD StudentCome DATE DROP语句DROP语句用于删除表项，其语句格式如下所示： DROP TABLE &lt;表名&gt;; -系统从数据字典中删去1、该基本表的描述；2、该基本表上的所有索引的描述。-系统从文件中删去表中数据-表上的视图仍然保留，但无法引用举例：删除Student表。DROP TABLE Student 数据库操作语句查询语句查询语句表达式如下所示: 12345678SELECT [ALL|DISTICT] &lt;目标表达式&gt;[&lt;别名&gt;] [,&lt;目标表达式&gt;[&lt;别名&gt;]]FROM &lt;表名或视图名&gt;[&lt;别名&gt;] [,&lt;表名或视图名&gt;[&lt;别名&gt;]][WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名&gt;[,&lt;列名&gt;] [HAVING&lt;条件表达式&gt;]][ORDER BY &lt;列名&gt;[,&lt;列名&gt;][ASC|DESC]]; -SELECT子句：指定要显示的属性列-FROM子句：指定查询对象（基本表或视图）-WHERE字句：指定查询条件-GROUP BY字句： 对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用集函数。-HAVING短语：筛选出满足指定条件的组-ORDER BY子句：对查询结果表按指定列序的升序排序或者降序排序 WHER子句 确认范围: BETWEEN…AND… / NOT BETWEEN…AND…比如 123SELECT Sname，Sdept，SageFROM StudentWHERE Sage BETWEEN 20 AND 23； 确认集合：IN &lt;值表&gt; NOT IN &lt;值表&gt;。&lt;值表&gt;：用逗号分隔的一组取值。比如 123SELECT Sname，SsexFROM StudentWHERE Sdept IN ( &apos;IS&apos;，&apos;MA&apos;，&apos;CS&apos; ); 字符串匹配：使用谓词LIKE或NOT LIKE [NOT] LIKE ‘&lt;匹配串&gt;’[ESCAPE‘&lt;换码字符&gt;‘]比如 123456789101112SELECT * FROM Student WHERE Sno = &apos;95001&apos;；SELECT Sname，Sno，SsexFROM StudentWHERE Sname LIKE ‘刘%’；SELECT Cno，CcreditFROM CourseWHERE Cname LIKE &apos;DB\\_Design&apos; ESCAPE &apos;\\&apos;使用换码字符将通配符转义为普通字符，ESCAPE换码字符 涉及空值的查询：使用谓语 IS NULL 或 IS NOT NULL 5类主要集函数 计数 COUNT([DISTINCT|ALL]*) COUNT([DISTINCT|ALL]&lt;列名&gt;) 计算总和 SUM([DISTINCT|ALL]&lt;列名&gt;) 计算平均值 AVG([DISTINCT|ALL]&lt;列名&gt;) 求最大值 MAX([DISTINCT|ALL]&lt;列名&gt;) 求最小值 MIN([DISTINCT|ALL]&lt;列名&gt;) -DISTINCT短语：在计算中要取消指定列中的重复值-ALL短语：不取消重复值-ALL为缺省值 使用集函数12345例： 计算1号课程的学生平均成绩。 SELECT AVG(Grade) FROM SC WHERE Cno= &apos; 1 &apos;； GROUP语句与HAVING语句 使用GROUP BY进行分组 分组方法：按指定的一列或多列值分组，值相等的为一组。 使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数 GROUP BY子句的作用对象是查询的中间结果表。 使用HAVING语句筛选最终结果 只有满足HAVING短语语句指定条件的组才输出。 HAVING短语与WHERE子句的不同：作用对象不同。WHERE基于表，HAVING作用于组。 12345查询选修了3门以上课程的学生学号SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*) &gt;3； 单表查询查询只涉及一个表，是一种最简单的查询操作。如果需要显示所有的列，并且按照原表顺序，可用SELECT *子句如果要消除重复的内容，可加DISTICT语句，比如SELECT DISTICT StudentNumber 连续查询同时涉及多个表的查询称为连接查询。123456SELECT Std.Sname, Std.Ssex, SdeptFROM Std，StdCWHERE Std.Sname = StdC.Sname /* 连接谓词 */AND Std.Ssex = StdC.Ssex /* 连接谓词 */AND StdC.Cno= &apos; 2 ‘ /* 其他限定条件 */AND StdC.Grade&gt;90； /* 其他限定条件 */ 嵌套查询概述：一个SELECT-FROM-WHERE语句称为一个查询块。将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询。123456SELECT Sname 外层查询/父查询FROM StudentWHERE Sno IN（SELECT Sno 内层查询/子查询 FROM SC WHERE Cno= &apos; 2 &apos;); 数据更新语句插入数据插入单个元组功能：将新元组插入指定表中。语句格式:123INSERTINTO &lt;表名&gt; [(&lt;属性列1&gt;[，&lt;属性列2 &gt;…)]VALUES (&lt;常量1&gt; [，&lt;常量2&gt;]…) INTO子句 指定要插入数据的表名及属性列 属性列的顺序可与表定义中的顺序不一致 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致 指定部分属性列：插入的元组在其余属性列上取空值 VALUES子句 提供的值必须与INTO子句匹配 插入子查询结果功能：将子查询结果插入指定表中。语句格式：123INSERT INTO &lt;表名&gt; [(&lt;属性列1&gt; [，&lt;属性列2&gt;… )]子查询: INFO子句与上相同。 子查询 SELCET子句目标项必须与INFO子句匹配。 修改数据功能： 修改指定表中满足WHERE子句条件的元组。语句格式：123UPDATE &lt;表名&gt;SET &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]； SET子句 指定要修改的方式。 WHERE子句 指定要修改的元组，缺省表示要修改所有的元组。示例： 123456UPDATE SCSET Grade=0WHERE &apos;CS&apos;=(SELETE Sdept FROM Student WHERE Student.Sno = SC.Sno)； 删除数据功能： 删除指定表中满足WHERE子句条件的元组。语句格式：123DELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;]； 视图建立视图在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。语句格式：1234CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [，&lt;列名&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION]； 组成视图的属性列名或全部省略或全部指定。 省略视图的各个属性列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成。 必须明确指定组成视图的所有列名的情形。 某个目标列不是单纯的属性名，而是集函数或列表达式 目标列为* 多表连接时选出了几个同名列作为视图的字段 需要在视图中为某个列启用新的更合适的名字 子查询 不含ORDER BY子句和DISTINCT短语的SELECT语句 WITH CHECK OPTION 透过视图进行增删改操作时，不得破坏视图定义中的谓词条件（即子查询中的条件表达式） JOIN语句有时为了得到完整的结果，我们需要从两个或更多的表中获取结果。我们就需要执行 join。数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。示例：12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName INNER JOIN(内连接):在表中存在至少一个匹配时，INNER JOIN 关键字返回行。 JOIN: 如果表中有至少一个匹配，则返回行。 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行。 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行。 FULL JOIN: 只要其中一个表中存在匹配，就返回行。","comments":true,"tags":[{"name":"数据库","slug":"数据库","permalink":"http://victorjiangxin.github.io/tags/数据库/"},{"name":"SQL语句","slug":"SQL语句","permalink":"http://victorjiangxin.github.io/tags/SQL语句/"}]},{"title":"比特币：脚本与地址","date":"2018-04-01T16:00:00.000Z","path":"/bitcoininin-scriptAddr/","text":"转自: https://furrybear.github.io/%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%EF%BC%9A%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%9C%B0%E5%9D%80/ 一些概念 非压缩式公钥65字节（04开头） 压缩式公钥33字节（02、03开头） 公钥哈希20字节 脚本哈希20字节（或者32字节，但是没有见过实例） 地址（由公钥哈希和脚本哈希组装和编码而来） P2PKH型：1开头，例如1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2，由公钥哈希组装和编码而来 P2SH型：3开头，例如3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy，由脚本哈希组装和编码而来 bech32型：bc1来头，例如bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq，它是前两种地址的另一种表达格式，现在blockchain.info只在有“native witness program”的时候使用这种格式 签名七十几字节（由第二个字节决定 非隔离见证(无Marker和Flag的) 锁定脚本：41&lt;非压缩式公钥&gt;(65bytes)AC（1开头地址） 锁定脚本(不太确定)：（P2PK型多重签名)OP_2 &lt;公钥1&gt; &lt;公钥2&gt; &lt;公钥3&gt; OP_3 CHECKMULTISIG(0xAE)（1开头地址） 锁定脚本：76A914&lt;公钥哈希&gt;(20bytes)88AC（1开头地址） 锁定脚本：76A920&lt;公钥哈希&gt;(32bytes)87AC（1开头地址） 锁定脚本：A914&lt;脚本哈希&gt;(20bytes)87（3开头地址） 锁定脚本：6A(40bytes?)（没有地址，资金锁住了）隔离见证交易（有marker和flag的） 锁定脚本：0014&lt;哈希&gt;(20bytes)（bc1开头地址） 锁定脚本：0020&lt;哈希&gt;(32bytes)（bc1开头地址） 锁定脚本：A914&lt;脚本哈希&gt;(20bytes)87（3开头地址） 锁定脚本：A920&lt;脚本哈希&gt;(32bytes)87（3开头地址）非隔离见证交易P2PKH（Pay-to-Public-Key-Hash）单签名（第一种）//解锁脚本： OP_DUP OP_HASH160锁定脚本：OP_DUP(0x76) OP_HASH160(0xA9) PUSHDATA20(0x14) (20bytes) OP_EQUAL(0x87) OP_CHECKSIG(0xAC)举例：（书上说有这种交易，没有找到实例）单签名（第二种）//解锁脚本： OP_DUP OP_HASH160锁定脚本：OP_DUP(0x76) OP_HASH160(0xA9) PUSHDATA20(0x14) (20bytes) OP_EQUALVERIFY(0x88) OP_CHECKSIG(0xAC)交易举例：99c2f5d3f1a1c89a4afa522361c55664e7777c71b02fd66cdf4e2ba190551d11、5a4ebf66822b0b2d56bd9dc64ece0bc38ee7844a23ff1d7320a88c5fdb2ad3e2P2PK（Pay-to-Public-Key）单签名锁定脚本：PUSHDATA65BYTES(0x41) &lt;非压缩式公钥&gt;(65bytes) OP_CHECKSIG(0xAC)(获取公钥后需要通过HASH160获得公钥哈希)这是比特币最早的锁定脚本，coinbase一般是这种形式。交易举例：创世区块的交易多重签名锁定脚本：M PUSHDATA65(0x41) PUSHDATA65(0x41)… PUSHDATA65(0x41) N OP_CHECKMULTISIG(0xAE)（因为实例没有找到，这个锁定脚本形式有待验证，因为M是个操作数，但是之前没有操作码）交易举例：（没找到）P2SH赎回脚本（2-3）：OP_2(0x52)OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥1&gt;OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥2&gt;OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥3&gt;OP_3(0x53)OP_CHECKMULTISIG(0xAE)解锁脚本：OP_PUSHDATA?BYTESOP_PUSHDATA?BYTESOP_PUSHDATA?BYTES &lt;赎回脚本&gt;锁定脚本：HASH160(0xA9)PUSHDATA20(0x14) &lt;脚本哈希（赎回脚本的HASH160）&gt;(20bytes) OP_EQUAL(0x87)举例：txid为521f7c6781ced91da6cc8eb4c64b283d2e99f98627daf8a3a0c60432d8e8f601的输入解锁脚本：12345678910111213141500//这是要注意！这是什么？？？版本号？OP_PUSHDATA71BYTES(0x47)3044022027eec2f3081b87d271e32e126c9ccb4d2c4afa7ef14f7cff644723784b720ede02203e278a13e3544bd32abe6592e4e17a7331272db4a2b780113ed24e3ca3c37f3201//签名1OP_PUSHDATA72BYTES(0x48)30450221009e450de0b27f95db02d7ab8b5943c62b8e2f50eabfb017f509684c4f58892d7802203b8640c5f17b8e6239a65f66bbb26ea952dac9d0eefffd114d97878b2ac1da4f01//签名1OP_PUSHDATA1(0x4c)69OP_2(0x52)OP_PUSHDATA33BYTES(0x21)02ca355b567bff51c9b4a1c1590e25f685f8d12273efb7f7685a50e546786d0de7//公钥1OP_PUSHDATA33BYTES(0x21)03e5fa93cffa7533c6b68906c4a9b8665f5167f3ed95b830328835ca4d39b6495f//公钥2OP_PUSHDATA33BYTES(0x21)03ee6664f625e0a44fad0ad53ae1ecdc7c7239346b81514e8f87cfd2be4f8fec21//公钥3OP_3(0x53) OP_CHECKMULTISIG(0xae) 锁定脚本：a914d0982dd391d674f101898e8500586019e01d9aa787 OPRETURN锁定脚本：OP_RETURN(0x6A) (40bytes?)输出不能被花费。 纯隔离见证交易witness_version在witness字段内，锁定脚本必然以一个版本号开头 P2WPKH（pay-to-witness-public-key-hash）witness:解锁脚本: 空锁定脚本: witness_version(0x00) PUSHDATA20BYTES(0x14) &lt;公钥哈希&gt;(20bytes) 交易举例：没有找到实例…… P2WSH（pay-to-witness-script-hash）witness: witness_version(0x00) OP_PUSHDATA?BYTES &lt;签名1&gt; OP_1 OP_PUSHDATA33BYTES &lt;压缩式公钥1&gt; OP_PUSHDATA33BYTES &lt;压缩式公钥2&gt; OP_2 OP_CHECKMULTISIG(0xAE)解锁脚本: 空锁定脚本1: witness_version(0x00) PUSHDATA32BYTES(0x20) &lt;脚本哈希&gt;(32bytes)锁定脚本2: witness_version(0x00) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt;(20bytes)锁定脚本3: witness_version(非0x00) PUSHDATA任意BYTES &lt;脚本哈希&gt;(任意bytes)(注意：P2SH的脚本哈希只有20字节，这里可以20字节或者32字节，32字节是为了防碰撞)交易举例：txid为d38f496e1004895c52d35bfe392800024b78b40e30dd063c4728058088ea0620交易的输入witness：1234567891011121314151604//？？witness_version(0x00)47304402203f87ea2cb39bf7b57f0ada40cfa7178a7b11548767d17be57e0e3a9ed818e53902202323afa3875a9917bf8227051ea5805ea5bc7a71f1ef8176884964a278aa2c2b01//签名47304402201055076d4a5284509a8c3e01abbe5e34e4fd79fe823914821bcaa7924333e0e40220495237c0d9acd7f16357de8c89e4eaab620ce5d26b810214e96272f4cf27b54e01//签名OP_VERIFY(0x69)OP_2(0x52)210375e00eb72e29da82b89367947f29ef34afb75e8654f6ea368e0acdfd92976b7c//公钥2103a1b26313f430c4b15bb1fdce663207659d8cac749a0e53d70eff01874496feff//公钥2103c96d495bfdd5ba4145e3e046fee45e84a8a48ad05bd8dbb395c011a32cf9f880//公钥OP_3(0x53)ae 将P2WPKH和P2WSH的witness program嵌入P2SH赎回脚本的部分witness_version在解锁脚本内。 P2WPKH nested in BIP16 P2SHwitness:解锁脚本: PUSHDATA22BYTES(0x16) witness_version(00)PUSHDATA22BYTES(0x14) &lt;公钥哈希&gt;(20bytes)锁定脚本: OP_HASH160(0xA9) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt;(20bytes) OP_EQUAL(0x87) 举例：交易c420d6cf09973d4a539cb17acdc42a3a89a89e0d6e28938a37951085d8433125的输出 P2WSH nested in BIP16 P2SHwitness:0 解锁脚本1: PUSHDATA34BYTES(0x22) witness_version(00) PUSHDATA32BYTES(0x20) &lt;脚本哈希&gt; (32bytes)解锁脚本2: PUSHDATA22BYTES(0x16) witness_version(00) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt; (20bytes)锁定脚本: OP_HASH160(0xa9) OP_PUSHDATA20(0x14) OP_EQUAL(0x87) 交易举例：4967d6427b17a17e91b524e9a4f8a810182c5f9995fd07fe2eab71d9cc96ecc0","comments":true,"tags":[{"name":"比特币脚本","slug":"比特币脚本","permalink":"http://victorjiangxin.github.io/tags/比特币脚本/"},{"name":"隔离见证","slug":"隔离见证","permalink":"http://victorjiangxin.github.io/tags/隔离见证/"}]},{"title":"异步编程C#","date":"2018-03-21T16:00:00.000Z","path":"/异步编程/","text":"Task与Thread的区别 Thread每次运行会创建一个新的线程，线程的创建、结束带来大量的开销。 Task每次运行时，会去线程池中寻找空闲的线程，将其分配使用。 Task及awit/asyncasync/await 结构可分成三部分： （1）调用方法：该方法调用异步方法，然后在异步方法执行其任务的时候继续执行； （2）异步方法：该方法异步执行工作，然后立刻返回到调用方法； （3）await 表达式：用于异步方法内部，指出需要异步执行的任务。一个异步方法可以包含多个 await 表达式（不存在 await 表达式的话 IDE 会发出警告）。 如何看异步代码？async定义的函数可分为以下几部分： await之前的部分；await部分；await之后的部分。当主函数运行到async函数时，先运行await之前的部分，遇到await后，线程分为两部分，（此时主线程从async函数中已经返回了）一个线程在主函数中继续运行，另一线程在继续运行await函数。PS:async函数内部的执行顺序，还是不变的，严格从上往下执行，即使有多个awit关键词，仍旧执行完前一个await语句后，再执行后一个await语句。 示例代码与输出12345678910111213141516171819202122232425262728293031class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;main thread start!&quot;); Task t = TestAsync(); Console.WriteLine(&quot;main thread end!&quot;); Console.Read(); &#125; private static async Task TestAsync() &#123; Console.WriteLine(&quot;Task start!&quot;); await Task.Run(() =&gt; &#123; Console.WriteLine(&quot;await0 start!&quot;); for (int i = 0; i &lt; 500000; i++) ; Console.WriteLine(&quot;await0 end!&quot;); &#125;); await Task.Run(()=&gt; &#123; Console.WriteLine(&quot;awit1 start!&quot;); for (int i = 0; i &lt; 5; i++) ; Console.WriteLine(&quot;awit1 end!&quot;); &#125; ); &#125; &#125; 运行结果如下所示：1234567main thread start!Task start!await0 start!main thread end!await0 end!awit1 start!awit1 end!","comments":true,"tags":[{"name":"C#","slug":"C","permalink":"http://victorjiangxin.github.io/tags/C/"},{"name":"异步编程","slug":"异步编程","permalink":"http://victorjiangxin.github.io/tags/异步编程/"}]}]